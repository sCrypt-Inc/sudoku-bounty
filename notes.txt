Alice (buyer) wants a solution w for a sudoku problem S, such that S(w) == true.
Bob (seller) computes this solution and wants to get compensatet in a trustless non-interactive way.

Alice (buyer):
-----
Qa = da * G

Bob (seller):
-----
Qb = db * G
x - secret solution


Shared key:  Qs = (da * db) * G = db * Qa


Poseidon encryption is used with Qs.x mod p (bn128) as the encryption key.


Definition of ZK circuit C:
------

def main(private w, private db, public Qa, public Qb, public ew) {
    // 1) Assert that w is the solution for S.
    // 2) Assert that (db * Qa) = Qs
    // 3) Assert that (db * G) = Qb
    // 4) Assert that encrypting w with Qs produces ew.
}



Bounty smart contract broadcasted by Alice:
------

contract BountySudokuSolution {
    PubKey Qa;
    VerifyingKey vk;

    int expirationBlockN;

    public function unlock(
                        PubKey Qb,   // Bobs public key
                        bytes ew     // Solution of sudoku puzzle, encrypted with shared key Qs
                        Proof pi,    // Proof of solution for the whole circuit C
                        SigHashPreimage preimage
                        ) {
        // 1) Assert that public inputs of the proof equal to Qa, Qb, pi
        // 2) Verify proof
        // 3) Ensure next output will pay Qb
    }


    public function deadline(Signature sig, SigHashPreimage preimage) {
        // 1) Check sig of Qa
        // 2) Check preimage to contain correct nLocktime etc.
    }

}


// TODO:
- How does bob ensure that proving key pk actually corresponds to vk before doing computation?
- Auto download sCrypt compiler if not present.
