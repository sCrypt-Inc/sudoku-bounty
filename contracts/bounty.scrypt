import "groth16/zksnark.scrypt";

struct ECPoint {
    int[4] x;
    int[4] y;
}

contract InformationBounty {
    ECPoint Qa;
    VerifyingKey vk;

    int satsReward;
    int expirationBlockN;

    public function unlock(
                        ECPoint Qb,   // Bobs public key
                        int[82] ew,   // Solution of puzzle, encrypted with shared key Qs
                        Sha256 Hew,   // Hash of ew
                        int nonce,    // Nonce for encryption with shared key. Can be timestamp.
                        Proof pi,     // Proof of solution for the whole circuit C
                        SigHashPreimage preimage
                    ) {
        
        bytes ewBytes = b'';
        loop (82) : i {
            ewBytes += toBEUnsigned(ew[i], 32);
        }
        require(sha256(ewBytes) == Hew);   // This ensures the seller included the correct ew.
         
        int[] pubInputs = [
                   this.Qa.x[0],
                   this.Qa.x[1],
                   this.Qa.x[2],
                   this.Qa.x[3],
                   this.Qa.y[0],
                   this.Qa.y[1],
                   this.Qa.y[2],
                   this.Qa.y[3],
                   Qb.x[0],
                   Qb.x[1],
                   Qb.x[2],
                   Qb.x[3],
                   Qb.y[0],
                   Qb.y[1],
                   Qb.y[2],
                   Qb.y[3],
                   nonce,
                   unpack(reverseBytes(Hew[:16], 16)),  // Hew is BE by default, hence the reverseBytes.
                   unpack(reverseBytes(Hew[16:], 16))
               ];
        bool proofCorrect = ZKSNARK.verifyOptimized(pubInputs, pi, this.vk);
        require(proofCorrect);

        // Ensure next output will pay Qb.
        require(Tx.checkPreimage(preimage));

        Ripemd160 pkh = hash160(point2PubKey(Qb));
        bytes outputScript0 = Utils.buildPublicKeyHashScript(pkh);       // TODO: this could just be P2PK because the PK is revealed beforehand anyway
        bytes output0 = Utils.buildOutput(outputScript0, this.satsReward);
        
        // Ensure the seller adds another output with just OP_FLASE + OP_RETURN + Qb + nonce + ew
        // to make it easier for the buyer to parse the values.
        bytes outputScript1 = b'006a' + point2PubKey(Qb) + toBEUnsigned(nonce, 32) + ewBytes;
        bytes output1 = Utils.buildOutput(outputScript1, 0);

        require(hash256(output0 + output1) == SigHash.hashOutputs(preimage));
    }


    public function deadline(Sig sig, SigHashPreimage preimage) {
        // Check if signature by Qa.
        require(checkSig(sig, point2PubKey(this.Qa)));

        // Ensure the unlocking TX actually has the correct nLocktime and nSequence.
        require(Tx.checkPreimage(preimage));
        require(SigHash.nSequence(preimage) < 0xFFFFFFFF);   // Lower than UINT_MAX. Check https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence
        require(SigHash.nLocktime(preimage) >= this.expirationBlockN && 
                SigHash.nLocktime(preimage) < 500000000);
    }

    static function point2PubKey(ECPoint point) : PubKey {
        // Convert a point to a uncompressed public key. Coordinates are encoded as BE values.
        // point.x[0] are the least significant bytes (also in BE format),
        // point.x[3] are the most significant bytes (also in BE format)
        return PubKey(b'04' + 
                toBEUnsigned(point.x[3], 8) +
                toBEUnsigned(point.x[2], 8) + 
                toBEUnsigned(point.x[1], 8) + 
                toBEUnsigned(point.x[0], 8) + 
                toBEUnsigned(point.y[3], 8) + 
                toBEUnsigned(point.y[2], 8) + 
                toBEUnsigned(point.y[1], 8) + 
                toBEUnsigned(point.y[0], 8));
    }

    static function toBEUnsigned(int n, static const  int l) : bytes {
        // Convert signed integer `n` to unsigned integer of `l` bytes, in big endian.
        bytes m = Utils.toLEUnsigned(n, l);
        return reverseBytes(m,l);
    }


}
