import "groth16/zksnark.scrypt";

struct ECPoint {
    int[4] x;
    int[4] y;
}

contract InformationBounty {
    ECPoint Qa;
    int x;   // w*w = x
    VerifyingKey vk;

    int satsReward;
    int expirationBlockN;

    public function unlock(
                        ECPoint Qb,   // Bobs public key
                        int ew,        // Solution of puzzle, encrypted with shared key Qs
                        Proof pi,     // Proof of solution for the whole circuit C
                        SigHashPreimage preimage
                    ) {

        int[] pubInputs = [
                   this.Qa.x[0],
                   this.Qa.x[1],
                   this.Qa.x[2],
                   this.Qa.x[3],
                   this.Qa.y[0],
                   this.Qa.y[1],
                   this.Qa.y[2],
                   this.Qa.y[3],
                   Qb.x[0],
                   Qb.x[1],
                   Qb.x[2],
                   Qb.x[3],
                   Qb.y[0],
                   Qb.y[1],
                   Qb.y[2],
                   Qb.y[3],
                   ew,
                   this.x
               ];
        bool proofCorrect = ZKSNARK.verifyOptimized(pubInputs, pi, this.vk);
        require(proofCorrect);

        // Ensure next output will pay Qb.
        require(Tx.checkPreimage(preimage));
        Ripemd160 pkh = hash160(point2PubKey(Qb));
        bytes outputScript = Utils.buildPublicKeyHashScript(pkh);       // TODO: this could just be P2PK because the PK is revealed beforehand anyway
        bytes output = Utils.buildOutput(outputScript, this.satsReward);
        require(hash256(output) == SigHash.hashOutputs(preimage));
    }


    public function deadline(Sig sig, SigHashPreimage preimage) {
        // Check if signature by Qa.
        require(checkSig(sig, point2PubKey(this.Qa)));

        // Ensure the unlocking TX actually has the correct nLocktime and nSequence.
        require(Tx.checkPreimage(preimage));
        require(SigHash.nSequence(preimage) < 0xFFFFFFFF);   // Lower than UINT_MAX. Check https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence
        require(SigHash.nLocktime(preimage) >= this.expirationBlockN && 
                SigHash.nLocktime(preimage) < 500000000);
    }

    static function point2PubKey(ECPoint point) : PubKey {
        // Convert a point to a uncompressed public key.
        return PubKey(b'04' + 
                toBEUnsigned(point.x[0], 8) + 
                toBEUnsigned(point.x[1], 8) + 
                toBEUnsigned(point.x[2], 8) + 
                toBEUnsigned(point.x[3], 8) + 
                toBEUnsigned(point.y[0], 8) + 
                toBEUnsigned(point.y[1], 8) + 
                toBEUnsigned(point.y[2], 8) + 
                toBEUnsigned(point.y[3], 8));
    }

    static function toBEUnsigned(int n, static const  int l) : bytes {
        // Convert signed integer `n` to unsigned integer of `l` bytes, in big endian.
        bytes m = Utils.toLEUnsigned(n, l);
        return reverseBytes(m,l);
    }


}
