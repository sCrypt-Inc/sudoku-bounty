import "groth16/zksnark.scrypt";

struct ECPoint {
    int[4] x;
    int[4] y;
}

contract InformationBounty {
    ECPoint Qa;
    int[82] x;   // Flattened solution to the sudoku puzzle.
    VerifyingKey vk;

    int satsReward;
    int expirationBlockN;

    public function unlock(
                        ECPoint Qb,   // Bobs public key
                        int[4] ew,    // Solution of puzzle, encrypted with shared key Qs
                        int nonce,    // Nonce for encryption with shared key. Can be timestamp.
                        Proof pi,     // Proof of solution for the whole circuit C
                        SigHashPreimage preimage
                    ) {

        int[] pubInputs = [
                   this.Qa.x[0],
                   this.Qa.x[1],
                   this.Qa.x[2],
                   this.Qa.x[3],
                   this.Qa.y[0],
                   this.Qa.y[1],
                   this.Qa.y[2],
                   this.Qa.y[3],
                   Qb.x[0],
                   Qb.x[1],
                   Qb.x[2],
                   Qb.x[3],
                   Qb.y[0],
                   Qb.y[1],
                   Qb.y[2],
                   Qb.y[3],
                   nonce,
                   ew[0],
                   ew[1],
                   ew[2],
                   ew[3],
                   this.x[0], this.x[1], this.x[2], this.x[3], this.x[4], this.x[5], this.x[6], this.x[7], this.x[8], this.x[9],
                   this.x[10], this.x[11], this.x[12], this.x[13], this.x[14], this.x[15], this.x[16], this.x[17], this.x[18], this.x[19],
                   this.x[20], this.x[21], this.x[22], this.x[23], this.x[24], this.x[25], this.x[26], this.x[27], this.x[28], this.x[29],
                   this.x[30], this.x[31], this.x[32], this.x[33], this.x[34], this.x[35], this.x[36], this.x[37], this.x[38], this.x[39],
                   this.x[40], this.x[41], this.x[42], this.x[43], this.x[44], this.x[45], this.x[46], this.x[47], this.x[48], this.x[49],
                   this.x[50], this.x[51], this.x[52], this.x[53], this.x[54], this.x[55], this.x[56], this.x[57], this.x[58], this.x[59],
                   this.x[60], this.x[61], this.x[62], this.x[63], this.x[64], this.x[65], this.x[66], this.x[67], this.x[68], this.x[69],
                   this.x[70], this.x[71], this.x[72], this.x[73], this.x[74], this.x[75], this.x[76], this.x[77], this.x[78], this.x[79],
                   this.x[80], this.x[81]
               ];
        bool proofCorrect = ZKSNARK.verifyOptimized(pubInputs, pi, this.vk);
        require(proofCorrect);

        // Ensure next output will pay Qb.
        require(Tx.checkPreimage(preimage));
        Ripemd160 pkh = hash160(point2PubKey(Qb));
        bytes outputScript = Utils.buildPublicKeyHashScript(pkh);       // TODO: this could just be P2PK because the PK is revealed beforehand anyway
        bytes output = Utils.buildOutput(outputScript, this.satsReward);
        require(hash256(output) == SigHash.hashOutputs(preimage));
    }


    public function deadline(Sig sig, SigHashPreimage preimage) {
        // Check if signature by Qa.
        require(checkSig(sig, point2PubKey(this.Qa)));

        // Ensure the unlocking TX actually has the correct nLocktime and nSequence.
        require(Tx.checkPreimage(preimage));
        require(SigHash.nSequence(preimage) < 0xFFFFFFFF);   // Lower than UINT_MAX. Check https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence
        require(SigHash.nLocktime(preimage) >= this.expirationBlockN && 
                SigHash.nLocktime(preimage) < 500000000);
    }

    static function point2PubKey(ECPoint point) : PubKey {
        // Convert a point to a uncompressed public key. Coordinates are encoded as BE values.
        // point.x[0] are the least significant bytes (also in BE format),
        // point.x[3] are the most significant bytes (also in BE format)
        return PubKey(b'04' + 
                toBEUnsigned(point.x[3], 8) +
                toBEUnsigned(point.x[2], 8) + 
                toBEUnsigned(point.x[1], 8) + 
                toBEUnsigned(point.x[0], 8) + 
                toBEUnsigned(point.y[3], 8) + 
                toBEUnsigned(point.y[2], 8) + 
                toBEUnsigned(point.y[1], 8) + 
                toBEUnsigned(point.y[0], 8));
    }

    static function toBEUnsigned(int n, static const  int l) : bytes {
        // Convert signed integer `n` to unsigned integer of `l` bytes, in big endian.
        bytes m = Utils.toLEUnsigned(n, l);
        return reverseBytes(m,l);
    }


}
