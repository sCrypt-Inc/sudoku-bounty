import "groth16/zksnark.scrypt";

struct ECPoint {
    int x;
    int y;
}

contract InformationBounty {
    ECPoint Qa;
    int x;   // w*w = x
    VerifyingKey vk;

    int satsReward;
    int expirationBlockN;

    public function unlock(
                        ECPoint Qb,   // Bobs public key
                        int ew        // Solution of puzzle, encrypted with shared key Qs
                        Proof pi,     // Proof of solution for the whole circuit C
                        SigHashPreimage preimage
                    ) {

        int[3] pubInputs = [this.Qa.x, this.Qa.y, Qb.x, Qb.y, ew, this.x];
        bool proofCorrect = verifyOptimized(pubInputs, pi, this.vk);
        require(proofCorrect);

        // Ensure next output will pay Qb.
        require(Tx.checkPreimage(preimage));
        Ripemd160 pkh = hash160(point2PubKey(Qb));
        bytes outputScript = Utils.buildPublicKeyHashScript(pkh);       // TODO: this could just be P2PK because the PK is revealed beforehand anyway
        bytes output = Utils.buildOutput(outputScript, satsReward);
        return (hash256(output) == SigHash.hashOutputs(txPreimage));
    }


    public function deadline(Signature sig, SigHashPreimage preimage) {
        // Check if signature by Qa.
        require(checkSig(sig, point2PubKey(this.Qa)));

        // Ensure the unlocking TX actually has the correct nLocktime and nSequence.
        require(Tx.checkPreimage(preimage));
        require(SigHash.nSequence(preimage) < 0xFFFFFFFF);   // Lower than UINT_MAX. Check https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence
        require(SigHash.nLocktime(preimage) >= this.expirationBlockN && 
                SigHash.nLocktime(preimage) < 500000000);
    }

    static function point2PubKey(ECPoint point) : PubKey {
        // Convert a point to a uncompressed public key.
        return PubKey(b'04' + toBEUnsigned(point.x, 32) + toBEUnsigned(point.y, 32));
    }
}
